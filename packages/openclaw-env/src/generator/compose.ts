import YAML from "yaml";
import type { ResolvedOpenClawEnvConfig } from "../config/load.js";

const OPENCLAW_CONTAINER_WORKSPACE = "/workspace";
const OPENCLAW_CONTAINER_CONFIG_PATH = "/etc/openclaw/openclaw-env.json5";
const OPENCLAW_CONTAINER_STATE_DIR = "/state/openclaw";
const OPENCLAW_CONTAINER_HOME = "/state/home";
const PROXY_CONTAINER_ALLOWLIST_PATH = "/etc/openclaw-env/allowlist.txt";

export type GeneratedArtifacts = {
  composeYaml: string;
  composeObject: unknown;
  openclawConfigJson5: string;
  allowlistText: string | null;
  proxyDockerfile: string | null;
  proxyServerJs: string | null;
};

function normalizeAllowlist(entries: string[]): string[] {
  const out: string[] = [];
  const seen = new Set<string>();
  for (const raw of entries) {
    const trimmed = raw.trim().toLowerCase();
    if (!trimmed) {
      continue;
    }
    if (seen.has(trimmed)) {
      continue;
    }
    seen.add(trimmed);
    out.push(trimmed);
  }
  return out;
}

export function generateOpenClawConfigJson5(cfg: ResolvedOpenClawEnvConfig): string {
  const skipBootstrap = cfg.workspace.mode === "ro";
  return `// Generated by openclaw-env. Do not edit by hand.
{
  agents: {
    defaults: {
      workspace: ${JSON.stringify(OPENCLAW_CONTAINER_WORKSPACE)},
      repoRoot: ${JSON.stringify(OPENCLAW_CONTAINER_WORKSPACE)},
      skipBootstrap: ${skipBootstrap ? "true" : "false"},
    },
  },
}
`;
}

export function generateAllowlistText(cfg: ResolvedOpenClawEnvConfig): string | null {
  if (cfg.network.mode !== "restricted") {
    return null;
  }
  const allowlist = normalizeAllowlist(cfg.network.restricted.allowlist);
  const header = [
    "# Generated by openclaw-env. Do not edit by hand.",
    "# One domain per line. Allow rule: host === entry OR host.endsWith('.' + entry)",
    "",
  ].join("\n");
  return `${header}${allowlist.join("\n")}${allowlist.length ? "\n" : ""}`;
}

export function generateProxyDockerfile(): string {
  return `FROM node:22-bookworm-slim

WORKDIR /app

COPY server.mjs /app/server.mjs

ENV NODE_ENV=production

USER node

EXPOSE 3128

CMD ["node", "/app/server.mjs"]
`;
}

export function generateProxyServerJs(): string {
  // Intentionally plain JS (no deps) to keep the proxy image tiny and deterministic.
  return `/* eslint-disable no-console */
import http from "node:http";
import net from "node:net";
import fs from "node:fs";

const listenHost = process.env.LISTEN_HOST || "0.0.0.0";
const listenPort = Number.parseInt(process.env.LISTEN_PORT || "3128", 10);
const allowlistPath = process.env.ALLOWLIST_PATH || ${JSON.stringify(PROXY_CONTAINER_ALLOWLIST_PATH)};

function loadAllowlist(filePath) {
  try {
    const raw = fs.readFileSync(filePath, "utf8");
    const lines = raw.split(/\\r?\\n/);
    const entries = [];
    const seen = new Set();
    for (const line of lines) {
      const trimmed = String(line || "").trim().toLowerCase();
      if (!trimmed || trimmed.startsWith("#")) continue;
      if (seen.has(trimmed)) continue;
      seen.add(trimmed);
      entries.push(trimmed);
    }
    return entries;
  } catch (err) {
    console.error("Failed to read allowlist:", filePath, String(err));
    return [];
  }
}

let allowlist = [];
let allowlistMtimeMs = -1;

function refreshAllowlistIfChanged() {
  try {
    const st = fs.statSync(allowlistPath);
    const nextMtime = typeof st.mtimeMs === "number" ? st.mtimeMs : 0;
    if (nextMtime !== allowlistMtimeMs) {
      allowlist = loadAllowlist(allowlistPath);
      allowlistMtimeMs = nextMtime;
    }
  } catch {
    if (allowlistMtimeMs !== 0) {
      allowlist = [];
      allowlistMtimeMs = 0;
    }
  }
  return allowlist;
}

refreshAllowlistIfChanged();

function isIpLiteral(host) {
  return net.isIP(host) !== 0;
}

function isAllowedHost(host) {
  const h = host.toLowerCase();
  const entries = refreshAllowlistIfChanged();
  for (const entry of entries) {
    if (h === entry) return true;
    if (h.endsWith("." + entry)) return true;
  }
  return false;
}

function deny(label, resOrSocket, reason) {
  const msg = "DENY " + label + " reason=" + reason;
  console.log(msg);
  try {
    if (typeof resOrSocket.writeHead === "function") {
      resOrSocket.writeHead(403, "Forbidden");
      resOrSocket.end("Forbidden\\n");
    } else if (resOrSocket && typeof resOrSocket.write === "function") {
      resOrSocket.write("HTTP/1.1 403 Forbidden\\r\\n\\r\\n");
      resOrSocket.destroy();
    }
  } catch {}
}

const server = http.createServer((req, res) => {
  try {
    const method = req.method || "GET";
    const rawUrl = req.url || "";
    const hostHeader = req.headers.host || "";

    // Proxy requests should use absolute-form; fallback to Host header.
    let target;
    try {
      target = new URL(rawUrl);
    } catch {
      // Best-effort fallback
      target = new URL("http://" + hostHeader + rawUrl);
    }

    const hostname = target.hostname || "";
    const port = Number.parseInt(target.port || "80", 10);
    const label = hostname + ":" + String(port);

    if (!hostname) {
      deny(label || "<empty>", res, "empty_host");
      return;
    }
    if (isIpLiteral(hostname)) {
      deny(label, res, "ip_literal");
      return;
    }
    if (!Number.isFinite(port) || port <= 0 || port > 65535) {
      deny(label, res, "invalid_port");
      return;
    }
    if (!isAllowedHost(hostname)) {
      deny(label, res, "not_allowlisted");
      return;
    }

    const headers = { ...req.headers };
    delete headers["proxy-connection"];
    delete headers["proxy-authorization"];

    const upstream = http.request(
      {
        protocol: "http:",
        hostname,
        port,
        method,
        path: target.pathname + target.search,
        headers,
      },
      (upstreamRes) => {
        res.writeHead(upstreamRes.statusCode || 502, upstreamRes.statusMessage, upstreamRes.headers);
        upstreamRes.pipe(res);
      },
    );
    upstream.on("error", (err) => {
      res.writeHead(502, "Bad Gateway");
      res.end("Bad Gateway\\n");
      console.log("ERROR http_forward " + label + " " + String(err));
    });
    req.pipe(upstream);
  } catch (err) {
    res.writeHead(500, "Proxy Error");
    res.end("Proxy Error\\n");
    console.log("ERROR proxy " + String(err));
  }
});

server.on("connect", (req, clientSocket, head) => {
  const raw = (req.url || "").trim();
  const label = raw || "<empty>";

  const idx = raw.lastIndexOf(":");
  if (idx <= 0 || idx === raw.length - 1) {
    deny(label, clientSocket, "malformed_connect");
    return;
  }

  const host = raw.slice(0, idx).trim().toLowerCase();
  const portStr = raw.slice(idx + 1).trim();
  const port = Number.parseInt(portStr, 10);
  const hostPort = host + ":" + portStr;

  if (!host) {
    deny(label, clientSocket, "empty_host");
    return;
  }
  if (isIpLiteral(host)) {
    deny(hostPort, clientSocket, "ip_literal");
    return;
  }
  if (!Number.isFinite(port) || port <= 0 || port > 65535) {
    deny(hostPort, clientSocket, "invalid_port");
    return;
  }
  if (!isAllowedHost(host)) {
    deny(hostPort, clientSocket, "not_allowlisted");
    return;
  }

  const upstreamSocket = net.connect(port, host, () => {
    clientSocket.write("HTTP/1.1 200 Connection Established\\r\\n\\r\\n");
    if (head && head.length) {
      upstreamSocket.write(head);
    }
    upstreamSocket.pipe(clientSocket);
    clientSocket.pipe(upstreamSocket);
  });

  upstreamSocket.on("error", (err) => {
    try {
      clientSocket.write("HTTP/1.1 502 Bad Gateway\\r\\n\\r\\n");
      clientSocket.destroy();
    } catch {}
    console.log("ERROR connect " + hostPort + " " + String(err));
  });
});

server.listen(listenPort, listenHost, () => {
  console.log("egress-proxy listening on " + listenHost + ":" + String(listenPort));
  console.log("allowlist entries=" + String(refreshAllowlistIfChanged().length));
});
`;
}

export function generateCompose(cfg: ResolvedOpenClawEnvConfig): GeneratedArtifacts {
  const openclawConfigJson5 = generateOpenClawConfigJson5(cfg);
  const allowlistText = generateAllowlistText(cfg);

  const volumes: string[] = [];
  volumes.push(
    `${cfg.workspace.hostPath}:${OPENCLAW_CONTAINER_WORKSPACE}:${cfg.workspace.mode}`,
  );
  for (const m of cfg.mounts) {
    volumes.push(`${m.hostPath}:${m.container}:${m.mode}`);
  }
  volumes.push(`${cfg.generated.openclawConfigPath}:${OPENCLAW_CONTAINER_CONFIG_PATH}:ro`);

  const env: Record<string, string> = {
    ...cfg.openclaw.env,
    HOME: OPENCLAW_CONTAINER_HOME,
    OPENCLAW_STATE_DIR: OPENCLAW_CONTAINER_STATE_DIR,
    OPENCLAW_CONFIG_PATH: OPENCLAW_CONTAINER_CONFIG_PATH,
  };

  if (cfg.network.mode === "restricted") {
    env.HTTP_PROXY = "http://egress-proxy:3128";
    env.HTTPS_PROXY = "http://egress-proxy:3128";
    env.NO_PROXY = "localhost,127.0.0.1,egress-proxy";
  }

  const openclawService: Record<string, unknown> = {
    image: cfg.openclaw.image,
    working_dir: OPENCLAW_CONTAINER_WORKSPACE,
    user: cfg.runtime.user,
    read_only: true,
    tmpfs: ["/tmp", "/run", "/state"],
    security_opt: ["no-new-privileges:true"],
    cap_drop: ["ALL"],
    pids_limit: cfg.limits.pids,
    mem_limit: cfg.limits.memory,
    cpus: cfg.limits.cpus,
    volumes,
    environment: env,
  };

  if (Array.isArray(cfg.openclaw.command)) {
    openclawService.command = cfg.openclaw.command;
  }

  if (cfg.secrets.mode === "env_file") {
    openclawService.env_file = [cfg.secrets.envFilePath];
  }

  if (cfg.secrets.mode === "docker_secrets" && cfg.secrets.dockerSecrets.length > 0) {
    openclawService.secrets = cfg.secrets.dockerSecrets.map((s) => s.name);
  }

  if (cfg.network.mode === "off") {
    openclawService.network_mode = "none";
  }

  if (cfg.network.mode === "restricted") {
    openclawService.networks = ["openclaw_internal"];
    openclawService.depends_on = ["egress-proxy"];
  }

  const services: Record<string, unknown> = {
    openclaw: openclawService,
  };

  let proxyDockerfile: string | null = null;
  let proxyServerJs: string | null = null;

  const networks: Record<string, unknown> = {};

  if (cfg.network.mode === "restricted") {
    proxyDockerfile = generateProxyDockerfile();
    proxyServerJs = generateProxyServerJs();

    services["egress-proxy"] = {
      build: {
        context: cfg.generated.proxyDir,
      },
      environment: {
        ALLOWLIST_PATH: PROXY_CONTAINER_ALLOWLIST_PATH,
        LISTEN_HOST: "0.0.0.0",
        LISTEN_PORT: "3128",
      },
      read_only: true,
      tmpfs: ["/tmp", "/run"],
      security_opt: ["no-new-privileges:true"],
      cap_drop: ["ALL"],
      user: cfg.runtime.user,
      volumes: [`${cfg.generated.allowlistPath}:${PROXY_CONTAINER_ALLOWLIST_PATH}:ro`],
      expose: ["3128"],
      networks: ["openclaw_internal", "openclaw_egress"],
    };

    networks["openclaw_internal"] = { internal: true };
    networks["openclaw_egress"] = {};
  }

  const secrets: Record<string, unknown> = {};
  if (cfg.secrets.mode === "docker_secrets") {
    for (const s of cfg.secrets.dockerSecrets) {
      secrets[s.name] = { file: s.filePath };
    }
  }

  const compose: Record<string, unknown> = {
    name: cfg.projectName,
    services,
  };

  if (Object.keys(networks).length > 0) {
    compose.networks = networks;
  }

  if (Object.keys(secrets).length > 0) {
    compose.secrets = secrets;
  }

  // Ensure stable output for tests.
  const yaml = YAML.stringify(compose, {
    lineWidth: 0,
  });

  return {
    composeYaml: yaml,
    composeObject: compose,
    openclawConfigJson5,
    allowlistText,
    proxyDockerfile,
    proxyServerJs,
  };
}


