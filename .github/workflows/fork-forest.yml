# Fork Forest Monitor
# ===================
# Monitora o ecossistema de forks em duas direÃ§Ãµes:
#
# HARVEST (colher)              SEED (semear)
#       â†“                            â†“
# [openclaw/openclaw]        [ekson73/openclaw]
#       â”‚                            â”‚
#    forks                        forks
#
# - Harvest: InovaÃ§Ãµes no upstream que podemos incorporar
# - Seed: AdoÃ§Ã£o do nosso trabalho por outros

name: Fork Forest Monitor

on:
  schedule:
    - cron: "0 7 * * 1" # Semanal, segunda 07:00 UTC
  workflow_dispatch:
    inputs:
      days_lookback:
        description: "Dias para anÃ¡lise de commits recentes"
        required: false
        default: "30"
        type: string

env:
  # Repos da floresta
  UPSTREAM_OWNER: openclaw
  UPSTREAM_REPO: openclaw
  OUR_OWNER: ekson73
  OUR_REPO: openclaw
  # ConfiguraÃ§Ã£o
  DAYS_LOOKBACK: ${{ inputs.days_lookback || '30' }}

jobs:
  # ============================================================
  # HARVEST: Colher inovaÃ§Ãµes dos forks do upstream
  # ============================================================
  harvest:
    name: ğŸŒ¾ Harvest - Upstream Forks
    runs-on: ubuntu-latest
    outputs:
      fork_count: ${{ steps.analyze.outputs.fork_count }}
      active_forks: ${{ steps.analyze.outputs.active_forks }}
      report: ${{ steps.analyze.outputs.report }}

    steps:
      - name: Analyze upstream forks
        id: analyze
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = '${{ env.UPSTREAM_OWNER }}';
            const repo = '${{ env.UPSTREAM_REPO }}';
            const ourFork = '${{ env.OUR_OWNER }}/${{ env.OUR_REPO }}';
            const daysBack = parseInt('${{ env.DAYS_LOOKBACK }}');
            const since = new Date(Date.now() - daysBack * 24 * 60 * 60 * 1000).toISOString();

            console.log(`ğŸŒ¾ Analyzing forks of ${owner}/${repo}`);
            console.log(`ğŸ“… Looking back ${daysBack} days (since ${since.split('T')[0]})`);

            // Fetch all forks (paginated)
            let forks = [];
            let page = 1;
            while (true) {
              const response = await github.rest.repos.listForks({
                owner,
                repo,
                per_page: 100,
                page
              });
              if (response.data.length === 0) break;
              forks = forks.concat(response.data);
              page++;
            }

            console.log(`ğŸ“Š Total forks found: ${forks.length}`);

            // Filter out our own fork (anti-duplication rule)
            const filteredForks = forks.filter(f => f.full_name !== ourFork);
            console.log(`ğŸ” After filtering ${ourFork}: ${filteredForks.length} forks`);

            // Analyze recent activity
            const activeForks = [];
            for (const fork of filteredForks.slice(0, 50)) { // Limit API calls
              try {
                const commits = await github.rest.repos.listCommits({
                  owner: fork.owner.login,
                  repo: fork.name,
                  since,
                  per_page: 10
                });
                
                // Filter commits that are ahead of upstream (not just syncs)
                const uniqueCommits = commits.data.filter(c => {
                  // Heuristic: commits with common sync messages are excluded
                  const msg = (c.commit.message || '').toLowerCase();
                  return !msg.includes('merge pull request') && 
                         !msg.includes('merge branch') &&
                         !msg.startsWith('merge remote');
                });
                
                if (uniqueCommits.length > 0) {
                  activeForks.push({
                    name: fork.full_name,
                    url: fork.html_url,
                    stars: fork.stargazers_count,
                    updated: fork.updated_at,
                    uniqueCommits: uniqueCommits.length,
                    latestCommit: uniqueCommits[0]?.commit.message?.split('\n')[0] || 'N/A'
                  });
                }
              } catch (e) {
                // Fork may be private or deleted
                console.log(`âš ï¸ Could not analyze ${fork.full_name}: ${e.message}`);
              }
            }

            // Sort by unique commits
            activeForks.sort((a, b) => b.uniqueCommits - a.uniqueCommits);

            // Generate report
            let report = `## ğŸŒ¾ Harvest Report - Upstream Forks\n\n`;
            report += `**Source:** [${owner}/${repo}](https://github.com/${owner}/${repo})\n`;
            report += `**Total forks:** ${forks.length}\n`;
            report += `**Active forks (${daysBack}d):** ${activeForks.length}\n\n`;

            if (activeForks.length > 0) {
              report += `### Top Active Forks\n\n`;
              report += `| Fork | â­ | Unique Commits | Latest |\n`;
              report += `|------|-----|----------------|--------|\n`;
              for (const f of activeForks.slice(0, 10)) {
                report += `| [${f.name}](${f.url}) | ${f.stars} | ${f.uniqueCommits} | ${f.latestCommit.substring(0, 40)}... |\n`;
              }
            } else {
              report += `*No forks with unique commits in the last ${daysBack} days.*\n`;
            }

            console.log(report);

            core.setOutput('fork_count', forks.length);
            core.setOutput('active_forks', activeForks.length);
            core.setOutput('report', report);

  # ============================================================
  # SEED: Verificar adoÃ§Ã£o do nosso trabalho
  # ============================================================
  seed:
    name: ğŸŒ± Seed - Our Forks
    runs-on: ubuntu-latest
    outputs:
      fork_count: ${{ steps.analyze.outputs.fork_count }}
      report: ${{ steps.analyze.outputs.report }}

    steps:
      - name: Analyze our forks
        id: analyze
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = '${{ env.OUR_OWNER }}';
            const repo = '${{ env.OUR_REPO }}';
            const daysBack = parseInt('${{ env.DAYS_LOOKBACK }}');
            const since = new Date(Date.now() - daysBack * 24 * 60 * 60 * 1000).toISOString();

            console.log(`ğŸŒ± Analyzing forks of ${owner}/${repo}`);

            // Fetch forks of our repo
            let forks = [];
            try {
              let page = 1;
              while (true) {
                const response = await github.rest.repos.listForks({
                  owner,
                  repo,
                  per_page: 100,
                  page
                });
                if (response.data.length === 0) break;
                forks = forks.concat(response.data);
                page++;
              }
            } catch (e) {
              console.log(`âš ï¸ Could not fetch forks: ${e.message}`);
            }

            console.log(`ğŸ“Š Total forks of our repo: ${forks.length}`);

            // Generate report
            let report = `## ğŸŒ± Seed Report - Our Downstream\n\n`;
            report += `**Source:** [${owner}/${repo}](https://github.com/${owner}/${repo})\n`;
            report += `**Total forks:** ${forks.length}\n\n`;

            if (forks.length > 0) {
              report += `### Adopters\n\n`;
              report += `| Fork | â­ | Created | Updated |\n`;
              report += `|------|-----|---------|--------|\n`;
              
              // Sort by creation date (newest first)
              forks.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
              
              for (const f of forks.slice(0, 10)) {
                const created = f.created_at.split('T')[0];
                const updated = f.updated_at.split('T')[0];
                report += `| [${f.full_name}](${f.html_url}) | ${f.stargazers_count} | ${created} | ${updated} |\n`;
              }
              
              if (forks.length > 10) {
                report += `\n*...and ${forks.length - 10} more*\n`;
              }
            } else {
              report += `*No forks yet. Our seeds are still germinating! ğŸŒ±*\n`;
            }

            console.log(report);

            core.setOutput('fork_count', forks.length);
            core.setOutput('report', report);

  # ============================================================
  # REPORT: Consolidar e criar issue
  # ============================================================
  report:
    name: ğŸ“Š Consolidated Report
    runs-on: ubuntu-latest
    needs: [harvest, seed]

    steps:
      - name: Generate consolidated report
        id: consolidate
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const harvestReport = `${{ needs.harvest.outputs.report }}`;
            const seedReport = `${{ needs.seed.outputs.report }}`;
            const upstreamForks = '${{ needs.harvest.outputs.fork_count }}';
            const activeForks = '${{ needs.harvest.outputs.active_forks }}';
            const ourForks = '${{ needs.seed.outputs.fork_count }}';

            const today = new Date().toISOString().split('T')[0];

            // Build consolidated report
            let body = `# ğŸŒ² Fork Forest Report - ${today}\n\n`;
            body += `> Weekly ecosystem monitoring for innovation and adoption.\n\n`;

            // Summary metrics
            body += `## ğŸ“ˆ Summary\n\n`;
            body += `| Metric | Value |\n`;
            body += `|--------|-------|\n`;
            body += `| Upstream forks (openclaw/openclaw) | ${upstreamForks} |\n`;
            body += `| Active upstream forks (30d) | ${activeForks} |\n`;
            body += `| Our downstream forks (ekson73/openclaw) | ${ourForks} |\n\n`;

            body += `---\n\n`;
            body += harvestReport;
            body += `\n---\n\n`;
            body += seedReport;

            body += `\n---\n\n`;
            body += `*Generated by [Fork Forest Monitor](../.github/workflows/fork-forest.yml)*\n`;

            // Create or update issue
            const title = `ğŸŒ² Fork Forest Report - ${today}`;
            const labels = ['fork-forest', 'automated'];

            // Check for existing issue
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'fork-forest',
              state: 'open',
              per_page: 1
            });

            if (existingIssues.data.length > 0) {
              // Update existing issue
              const issueNumber = existingIssues.data[0].number;
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                title,
                body
              });
              console.log(`ğŸ“ Updated issue #${issueNumber}`);
            } else {
              // Create new issue
              const newIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                body,
                labels
              });
              console.log(`ğŸ“ Created issue #${newIssue.data.number}`);
            }

            console.log('âœ… Fork Forest report complete!');
